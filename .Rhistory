v0 = v0,
S0 = S0,
time_max = time_max,
M_iter = M_iter,
eta = eta,
lambda = lambda,
N.max = N.max)
if (result$probs <= result$cutoff) { trial.stop<-1; trialER.stop <-1 }
}
pts.stop<-n.current;
if (pts.stop==N.max) {trialER.stop<-0}
### early stop for the last cohort; trial.stop =1, while not early stoped.
stop.all[i.sim]<-trial.stop;
stop.early[i.sim] <-trialER.stop;
pts.all[i.sim] <-pts.stop;
}
MyRaw <- data.frame(PRN=1-stop.all, PEN=stop.early, EN=pts.all);
mysim1<-(apply(MyRaw,2,mean));
mysim1<- round(mysim1,3);
return(list(mysim1 = mysim1, mu = c(mu.trt,mu.ctrl), Sigma.trt = Sigma.trt, Sigma.ctrl = Sigma.ctrl,
lambda = lambda))
}
OCC.Table(N.sim = 2,
N.max = 100,
mu.trt = c(log(2), log(5)),
Sigma.trt = matrix(c(1, 0.5, 0.5, 1), ncol=2),
mu.ctrl= c(log(2), log(5)),
Sigma.ctrl = matrix(c(1, 0.5, 0.5, 1), ncol=2),
cens_upper = 20,
cohort = c(40,60,80,100),
recruit.int  = 0.25,
m0 = c(0,0),
k0 = 0.001,
v0 = 4,
S0 = diag(0.001, 2),
time_max = 20,
M_iter = 10,
eta = 1,
lambda = 0.25
)
getwd()
result <- readRDS("C:/Users/huang/OneDrive - The University of Texas Health Science Center at Houston/dissertation/code/win ratio/result/0912_sim1/result_forthetuned_lambda.rds")
result
result_test1 <- readRDS("C:/Users/huang/OneDrive - The University of Texas Health Science Center at Houston/dissertation/code/win ratio/result/0912_sim1/result_test1.rds")
View(result_test1)
result_test1
result_test <- readRDS("C:/Users/huang/OneDrive - The University of Texas Health Science Center at Houston/dissertation/code/win ratio/result/0912_sim1/result_test.rds")
result_test
library(test)
?glm
?quantile
vignette("rd")
library(remotes)
library(devtools)
library(roxygen2)
RcppArmadillo::RcppArmadillo.package.skeleton("test2", example_code = F)
remove.packages("Rcpp")
library(remotes)
library(devtools)
library(roxygen2)
RcppArmadillo::RcppArmadillo.package.skeleton("test11", example_code = F)
library(remotes)
library(devtools)
library(roxygen2)
RcppArmadillo::RcppArmadillo.package.skeleton("test12", example_code = F)
burn_MCMC = as.integer(0.3*100000)
idxs <- seq(burn_MCMC, Niter, by = 5)
burn_MCMC = as.integer(0.3*100000)
idxs <- seq(burn_MCMC, 100000, by = 5)
M_iter = length(idxs)
burn_MCMC = as.integer(0.3*50000)
idxs <- seq(burn_MCMC, 50000, by = 5)
M_iter = length(idxs)
burn_MCMC = as.integer(0.3*100000)
idxs <- seq(burn_MCMC, 100000, by = 5)
M_iter = length(idxs)
length(c(600,900,1200))
1/0.07
0.01*1000
(900/1262)^26
(900/1262)^27
1/7000
1/15000
library(remotes)
library(devtools)
library(roxygen2)
RcppArmadillo::RcppArmadillo.package.skeleton("BayesianWinRatio", example_code = F)
library(remotes)
library(devtools)
library(roxygen2)
RcppArmadillo::RcppArmadillo.package.skeleton("tAUC-CR", example_code = F)
RcppArmadillo::RcppArmadillo.package.skeleton("tAUC_CR", example_code = F)
RcppArmadillo::RcppArmadillo.package.skeleton("tAUCCR", example_code = F)
load("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/mypackages/tAUCCR/data/demo.rda")
View(outcome)
View(outcome)
outcome[[1]]
load("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/mypackages/tAUCCR/data/demo.rda")
load("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/mypackages/tAUCCR/data/demo.rda")
load("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/mypackages/tAUCCR/data/demo.rda")
View(demo)
View(demo)
conditions <- enquos(bpi == bpl, DRUGi == DRUGl, GENDERi == GENDERl)
library(rlang)
conditions <- enquos(bpi == bpl, DRUGi == DRUGl, GENDERi == GENDERl)
squared_diffs <- vector("list", length(var_pairs))
var_pairs = list(
age = c("agei", "agel"),
bmi = c("bmii", "bmil"))
squared_diffs <- vector("list", length(var_pairs))
View(squared_diffs)
names(squared_diffs) <- names(var_pairs)
for (var in names(var_pairs)) {
pair <- var_pairs[[var]]
squared_diffs[[var]] <- paste0("(", pair[1], " - ", pair[2], ")^2")
}
sum_of_squares_expr <- paste(squared_diffs, collapse = " + ")
final_expr <- paste0("sqrt(", sum_of_squares_expr, ")")
final_expr
cont_vars =  c("age", "bmi")
# Assume `cont_vars` is a vector of continuous variable names, e.g., cont_vars <- c("age", "bmi")
squared_diffs <- vector("list", length(cont_vars))
View(squared_diffs)
# Name each element in squared_diffs by the variable name
names(squared_diffs) <- cont_vars
View(squared_diffs)
# Loop over each variable name in cont_vars and create the squared difference expression
for (var in cont_vars) {
# Create case and control versions by appending "i" and "l" to the variable name
case_var <- paste0(var, "i")
control_var <- paste0(var, "l")
# Store the squared difference expression
squared_diffs[[var]] <- paste0("(", case_var, " - ", control_var, ")^2")
}
# Create the final expression for the sum of squares
sum_of_squares_expr <- paste(squared_diffs, collapse = " + ")
final_expr <- paste0("sqrt(", sum_of_squares_expr, ")")
# final_expr now contains the full expression
final_expr
discrete_vars = c("bpi", "DRUG", "GENDER")
conditions <- lapply(discrete_vars, function(var) {
paste0(var, "i == ", var, "l")
})
View(conditions)
discrete_vars = c("bp", "DRUG", "GENDER")
conditions <- lapply(discrete_vars, function(var) {
paste0(var, "i == ", var, "l")
})
conditions_expr <- paste(conditions, collapse = " & ")
conditions_expr
eval(parse(text = conditions_expr))
text
conditions <- lapply(discrete_vars, function(var) {
sym_case <- sym(paste0(var, "i"))
sym_control <- sym(paste0(var, "l"))
expr(!!sym_case == !!sym_control)
})
conditions
nx<-ncol(vxs)
n = nrow(data); vt = Y0 vc =  C0;  vn = M0; vxs =  VXS; eta = 1, c0 = 1
n = nrow(data); vt = Y0 vc =  C0;  vn = M0; vxs =  VXS; eta = 1; c0 = 1
n = nrow(data); vt = Y0; vc =  C0;  vn = M0; vxs =  VXS; eta = 1; c0 = 1
vt
Sys.setenv(GITHUB_PAT = "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")
devtools::install_github("xinran-h/tAUCCR", auth_token = Sys.getenv("GITHUB_PAT"))
devtools::install_github("xinran-h/tAUCCR", auth_token = Sys.getenv("GITHUB_PAT"))
devtools::install_github("xinran-h/tAUCCR", auth_token = Sys.getenv("GITHUB_PAT"), force = T)
Sys.setenv(GITHUB_PAT = "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")
devtools::install_github("xinran-h/tAUCCR", auth_token = Sys.getenv("GITHUB_PAT"))
library(tAUCCR)
dd = tAUCCR::demo
# obtain the arguments from the demo data
n = nrow(dd)
Y0 = dd$Y
C0 = dd$delta
M0 = dd$M
VXS = dd[,c("xd","xc")]
c0 = 2
cont_vars = c("xc")
discrete_vars = c("xd")
dd_crossed1 = data_crossingdc(n, Y0,C0,M0,VXS,1,2, cont_vars, discrete_vars)
dd_crossed2 = data_crossingdc(n, Y0,C0,M0,VXS,2,2, cont_vars, discrete_vars)
# install if not installed
# install.packages("fastglm")
library(fastglm)
covariates_i <- paste0(c("xd", "xc"), "i")
YI = dd_crossed1$yi
XS<- as.matrix(cbind(int = 1,
t1 = YI^(-2),
t2 = YI^(-1),
t3 = YI^(-0.5),
t4 = log(YI),
t5 = YI^(0.5),
t6 = YI,
t7 = YI^(2),
dd_crossed1[covariates_i]))
YS<-dd_crossed1$Iil
rho01<-dd_crossed1$rho01
rho02<-dd_crossed1$rho02
rhoweight<-dd_crossed1$rhoweight
ordic=dd_crossed1$i-1
ordjc=dd_crossed1$l-1
gc()
outcome <- fastglm(XS,YS,weights = rhoweight,family=binomial(link="logit"),maxit=10000L)
beta.hat = outcome$coefficients
L=covariance_cal_wrapper(beta.hat,M0,rho01,rho02,t(XS),ordic,ordjc)
V = L$v
V
L
beta.hat
t0 <- seq(0, 10, by = 0.1)
cov.val = c(1,0)
ci <- auc_pred(beta.hat,V,t0,cov.val,  nf=7)
nf=7
n0 <- length(beta.hat)-nf-1
se.store.1<- matrix(0,ncol=length(t0),nrow=2)
for(i in 1:length(t0)){
if (nf == 3) {
poly <- c(1, log(t0[i]), t0[i], t0[i]^2, cov.val)
}else if (nf == 7){
poly <- c(1,t0[i]^(-2),t0[i]^(-1),t0[i]^(-.5),log(t0[i]),t0[i]^(.5),t0[i],t0[i]^2,cov.val)
}
temp <- c(beta.hat %*% poly)
lower <- temp- 1.96*sqrt(max(0,c(poly %*% V %*% poly)) )
upper <- temp+ 1.96*sqrt(max(0,c(poly %*% V %*% poly)) )
se.store.1[1,i] <- 1/(1+exp(-temp))
se.store.1[2,i] <- 1/(1+exp(-lower))
se.store.1[3,i] <-  1/(1+exp(-upper))
}
i=1
poly <- c(1,t0[i]^(-2),t0[i]^(-1),t0[i]^(-.5),log(t0[i]),t0[i]^(.5),t0[i],t0[i]^2,cov.val)
poly
View(dd)
t0 <- seq(0.1, 1, by = 0.1)
cov.val = c(1,0)
ci <- auc_pred(beta.hat,V,t0,cov.val,  nf=7)
poly <- c(1,t0[i]^(-2),t0[i]^(-1),t0[i]^(-.5),log(t0[i]),t0[i]^(.5),t0[i],t0[i]^2,cov.val)
poly
temp <- c(beta.hat %*% poly)
lower <- temp- 1.96*sqrt(max(0,c(poly %*% V %*% poly)) )
upper <- temp+ 1.96*sqrt(max(0,c(poly %*% V %*% poly)) )
upper
temp
lower
View(dd)
beta.hat
L=covariance_cal_wrapper(beta.hat,M0,rho01,rho02,t(XS),ordic,ordjc)
V = L$v
L
datasimdc<-function(n,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,cen)
{
## input
#n: number of observations
#rho_m1: correlation between biomarker and event of interest
#rho_m2: correlation between biomarker and the competing event
#rho_m1: correlation between the competing event and event of interest
#sd: standard deviation
#tau: censoring
#coef_assu: the coefficient assumption on mu_m  (coefficient for xd, coefficient for xc,intercept),
##        mu_logt1 (coefficient for xd, coefficient for xc,intercept),
## and mu_logt2 (coefficient for xd, coefficient for xc,intercept)
#p: prob for xd
#cen: % of censoring, 0 - no censoring, 15 - 15%, 30 - 30%
## output:
# data.frame(
#   Y = Y,    # observed time
#   delta = delta,  # event indicator: 0 - censored, 1 - event of interest, 2 - competing events
#   xd = xd,  # discrete covariate: 0, 1
#   xc = xc, # continous covariate
#   M = M     # biomarker
# ) ordered by Y.
coef.d.m<-coef_assu[1] #new
coef.c.m<-coef_assu[2] #new
int.m<-coef_assu[3]
coef.d.t1<-coef_assu[4] #new
coef.c.t1<-coef_assu[5] #new
int.t1<-coef_assu[6]
coef.d.t2<-coef_assu[7] #new
coef.c.t2<-coef_assu[8] #new
int.t2<-coef_assu[9]  #new
xd<-rbinom(n,1,p)
xc<-runif(n,0,1)
mu_m<-coef.d.m*xd + coef.c.m*xc + int.m #new
mu_logt1<-coef.d.t1*xd + coef.c.t1*xc + int.t1 #new
mu_logt2<-coef.d.t2*xd + coef.c.t2*xc + int.t2 #new
data <-matrix(0L, nrow = n, ncol = 3) #new
cov4 = matrix(0L, nrow = 3, ncol = 3) #new
cov4[upper.tri(cov4, diag = TRUE)] <- c(sd^2,rho_m1*sd*sd,sd*sd, rho_m2*sd*sd, rho_12*sd*sd, sd^2)#new
cov4[lower.tri(cov4)] <- t(cov4)[lower.tri(cov4)]#new
for (i in 1:n){
data[i,] <- rmvnorm(1,mean=c(mu_m[i],mu_logt1[i],mu_logt2[i]),sigma = cov4) #new
}
M <- data[,1]
logt1 <- data[,2]
logt2 <- data[,3] #new
T_tilda <- exp(pmin(logt1, logt2)) #new
if (cen==0){
C <- tau
Y <- apply(rbind(T_tilda,C),2,min) #new
}else{
C <- runif(n,min=0,max=tau)
Y <- apply(rbind(T_tilda,C),2,min) #new
}
delta <- ifelse(T_tilda > C, 0, ifelse(logt1 <= logt2, 1, 2)) #new
dat <- data.frame(
Y = Y,
delta = delta,
xd = xd,
xc = xc,
M = M
)
dat0 <- dat[order(Y),]
return(dat0)
}
p = 0.5
rho_m1 = -0.7
rho_m2 = 0
rho_12 = 0
sd = 1
coef_assu<- c(-1,-1,-1,1,1.2, 1, 0.2,0.4, 2)
demo = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,cen)
library(mvtnorm)
demo = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,cen)
demo = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,30)
demo = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,30)
tau_t <- readRDS("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/projects/proj2_competing/biomarker/competing risks/Discrete and Continuous/other_settings/interim dataset/S3/tau_t.rds")
demo = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau_t$tau30,coef_assu,p,30)
View(demo)
# install if not installed
# install.packages("fastglm")
library(fastglm)
covariates_i <- paste0(c("xd", "xc"), "i")
YI = dd_crossed1$yi
XS<- as.matrix(cbind(int = 1,
t1 = YI^(-2),
t2 = YI^(-1),
t3 = YI^(-0.5),
t4 = log(YI),
t5 = YI^(0.5),
t6 = YI,
t7 = YI^(2),
dd_crossed1[covariates_i]))
YS<-dd_crossed1$Iil
rho01<-dd_crossed1$rho01
rho02<-dd_crossed1$rho02
rhoweight<-dd_crossed1$rhoweight
ordic=dd_crossed1$i-1
ordjc=dd_crossed1$l-1
gc()
outcome <- fastglm(XS,YS,weights = rhoweight,family=binomial(link="logit"),maxit=10000L)
beta.hat = outcome$coefficients
L=covariance_cal_wrapper(beta.hat,M0,rho01,rho02,t(XS),ordic,ordjc)
V = L$v
L
dd = demo
# obtain the arguments from the demo data
n = nrow(dd)
Y0 = dd$Y
C0 = dd$delta
M0 = dd$M
VXS = dd[,c("xd","xc")]
c0 = 2
cont_vars = c("xc")
discrete_vars = c("xd")
dd_crossed1 = data_crossingdc(n, Y0,C0,M0,VXS,1,2, cont_vars, discrete_vars)
dd_crossed2 = data_crossingdc(n, Y0,C0,M0,VXS,2,2, cont_vars, discrete_vars)
# install if not installed
# install.packages("fastglm")
library(fastglm)
covariates_i <- paste0(c("xd", "xc"), "i")
YI = dd_crossed1$yi
XS<- as.matrix(cbind(int = 1,
t1 = YI^(-2),
t2 = YI^(-1),
t3 = YI^(-0.5),
t4 = log(YI),
t5 = YI^(0.5),
t6 = YI,
t7 = YI^(2),
dd_crossed1[covariates_i]))
YS<-dd_crossed1$Iil
rho01<-dd_crossed1$rho01
rho02<-dd_crossed1$rho02
rhoweight<-dd_crossed1$rhoweight
ordic=dd_crossed1$i-1
ordjc=dd_crossed1$l-1
gc()
outcome <- fastglm(XS,YS,weights = rhoweight,family=binomial(link="logit"),maxit=10000L)
beta.hat = outcome$coefficients
L=covariance_cal_wrapper(beta.hat,M0,rho01,rho02,t(XS),ordic,ordjc)
V = L$v
V
packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, repos='https://cran.rstudio.com/')
sapply(pkg, require, character.only = TRUE)
}
packages(c("mvtnorm","fastglm",   #statistical methods
"dplyr","tidyr","purrr", #efficient R from tidyverse
"parallel"
))
p = 0.5
rho_m1 = -0.7
rho_m2 = 0
rho_12 = 0
sd = 1
coef_assu<- c(-1,-1,-1,1,1.2, 1, 0.2,0.4, 2)
tau_t <- readRDS("C:/Users/huang/OneDrive - UTHealth Houston/dissertation/projects/proj2_competing/biomarker/competing risks/Discrete and Continuous/other_settings/interim dataset/S3/tau_t.rds")
#### * 1. c) discrete and continuous ####
datasimdc<-function(n,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,cen)
{
## input
#n: number of observations
#rho_m1: correlation between biomarker and event of interest
#rho_m2: correlation between biomarker and the competing event
#rho_m1: correlation between the competing event and event of interest
#sd: standard deviation
#tau: censoring
#coef_assu: the coefficient assumption on mu_m  (coefficient for xd, coefficient for xc,intercept),
##        mu_logt1 (coefficient for xd, coefficient for xc,intercept),
## and mu_logt2 (coefficient for xd, coefficient for xc,intercept)
#p: prob for xd
#cen: % of censoring, 0 - no censoring, 15 - 15%, 30 - 30%
## output:
# data.frame(
#   Y = Y,    # observed time
#   delta = delta,  # event indicator: 0 - censored, 1 - event of interest, 2 - competing events
#   xd = xd,  # discrete covariate: 0, 1
#   xc = xc, # continous covariate
#   M = M     # biomarker
# ) ordered by Y.
coef.d.m<-coef_assu[1] #new
coef.c.m<-coef_assu[2] #new
int.m<-coef_assu[3]
coef.d.t1<-coef_assu[4] #new
coef.c.t1<-coef_assu[5] #new
int.t1<-coef_assu[6]
coef.d.t2<-coef_assu[7] #new
coef.c.t2<-coef_assu[8] #new
int.t2<-coef_assu[9]  #new
xd<-rbinom(n,1,p)
xc<-runif(n,0,1)
mu_m<-coef.d.m*xd + coef.c.m*xc + int.m #new
mu_logt1<-coef.d.t1*xd + coef.c.t1*xc + int.t1 #new
mu_logt2<-coef.d.t2*xd + coef.c.t2*xc + int.t2 #new
data <-matrix(0L, nrow = n, ncol = 3) #new
cov4 = matrix(0L, nrow = 3, ncol = 3) #new
cov4[upper.tri(cov4, diag = TRUE)] <- c(sd^2,rho_m1*sd*sd,sd*sd, rho_m2*sd*sd, rho_12*sd*sd, sd^2)#new
cov4[lower.tri(cov4)] <- t(cov4)[lower.tri(cov4)]#new
for (i in 1:n){
data[i,] <- rmvnorm(1,mean=c(mu_m[i],mu_logt1[i],mu_logt2[i]),sigma = cov4) #new
}
M <- data[,1]
logt1 <- data[,2]
logt2 <- data[,3] #new
T_tilda <- exp(pmin(logt1, logt2)) #new
if (cen==0){
C <- tau
Y <- apply(rbind(T_tilda,C),2,min) #new
}else{
C <- runif(n,min=0,max=tau)
Y <- apply(rbind(T_tilda,C),2,min) #new
}
delta <- ifelse(T_tilda > C, 0, ifelse(logt1 <= logt2, 1, 2)) #new
dat <- data.frame(
Y = Y,
delta = delta,
xd = xd,
xc = xc,
M = M
)
dat0 <- dat[order(Y),]
return(dat0)
}
datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau,coef_assu,p,cen)
dd = datasimdc(400,rho_m1, rho_m2,rho_12,sd,tau_t$tau30,coef_assu,p,30)
save(dd, "demo.rda")
save(dd, file="demo.rda")
library(remotes)
library(devtools)
library(roxygen2)
setwd("BayesianWinRatioRAR")
setwd("../BayesianWinRatio")
Rcpp::compileAttributes()
# add documentation for package itself
usethis::use_package_doc() # do not need to modify. running roxygen2::roxygenize(roclets="rd") will update .rd
roxygen2::roxygenize(roclets="rd") # this updates the documentation; use this when also compile Rcpp.
devtools::document()  # Rebuild the NAMESPACE file
setwd('../tAUCCR')
# add documentation for package itself
usethis::use_package_doc() # do not need to modify. running roxygen2::roxygenize(roclets="rd") will update .rd
Rcpp::compileAttributes()
# add documentation for package itself
usethis::use_package_doc() # do not need to modify. running roxygen2::roxygenize(roclets="rd") will update .rd
roxygen2::roxygenize(roclets="rd") # this updates the documentation; use this when also compile Rcpp.
devtools::document()  # Rebuild the NAMESPACE file
Rcpp::compileAttributes()
# for proj2:
usethis::use_package("rlang")
usethis::use_package("Rcpp")
usethis::use_package("dplyr")
usethis::use_package("tidyr")
usethis::use_package("stats")
use_mit_license()
# add documentation for package itself
usethis::use_package_doc() # do not need to modify. running roxygen2::roxygenize(roclets="rd") will update .rd
roxygen2::roxygenize(roclets="rd") # this updates the documentation; use this when also compile Rcpp.
devtools::document()  # Rebuild the NAMESPACE file
## add vignettes: follow the steps in https://r-pkgs.org/vignettes.html
### A vignette in R is a detailed document that provides a comprehensive and in-depth guide to using a package. It often includes background information, explanations of the package's design and functions, examples of typical use cases, and demonstrations of the package's capabilities. Vignettes are meant to be educational resources that can help users understand not just how to use the package, but also why it works the way it does.
usethis::use_vignette("BayesWinRatio")
